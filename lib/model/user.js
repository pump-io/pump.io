// user.js
//
// A local user; distinct from a person
//
// Copyright 2011,2012 StatusNet Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var databank = require('databank'),
    _ = require('underscore'),
    DatabankObject = databank.DatabankObject,
    Stamper = require('../stamper').Stamper,
    bcrypt  = require('bcrypt'),
    Step = require('step'),
    Person = require('./person').Person,
    Stream = require('./stream').Stream,
    Activity = require('./activity').Activity,
    ActivityObject = require('./activityobject').ActivityObject,
    Edge = require('./edge').Edge,
    Favorite = require('./favorite').Favorite,
    URLMaker = require('../urlmaker').URLMaker,
    NoSuchThingError = databank.NoSuchThingError;

var User = DatabankObject.subClass('user');

exports.User = User;

// for updating

User.prototype.beforeUpdate = function(props, callback) {

    // XXX: required, but immutable. Boooooo.

    if (!_(props).has('nickname')) {
        callback(new Error("'nickname' property is required"), null);
        return;
    } else if (props.nickname !== this.nickname) {
        callback(new Error("'nickname' is immutable"), null);
        return;
    } else {
        delete props.nickname;
    }

    // XXX: required. Seems not strictly necessary, but whatever.

    if (!_(props).has('password')) {
        callback(new Error("'password' property is required"), null);
        return;
    }

    // Callers must omit or leave equal

    if (_(props).has('published')) {
        if (props.published !== this.published) {
            callback(new Error("'published' is autogenerated and immutable"), null);
            return;
        } else {
            delete props.published;
        }
    }

    // Callers must omit or leave equal

    if (_(props).has('profile')) {
        // XXX: we should probably do some deep-equality check
        if (!_(props.profile).has('id') || props.profile.id !== this.profile.id ||
            !_(props.profile).has('objectType') || props.profile.objectType !== this.profile.objectType ||
            !_(props.profile).has('displayName') || props.profile.displayName !== this.profile.displayName) {
            callback(new Error("'profile' is immutable"), null);
            return;
        } else {
            delete props.profile;
        }
    }

    // Callers must omit or leave equal

    if (_(props).has('updated') && props.updated !== this.updated) {
        callback(new Error("'updated' is autogenerated"), null);
        return;
    }

    props.updated = Stamper.stamp();

    Step(
        function() {
            bcrypt.genSalt(10, this);
        },
        function(err, salt) {
            if (err) throw err;
            bcrypt.hash(props.password, salt, this);
        },
        function(err, hash) {
            if (err) {
                callback(err, null);
            } else {
                props.passwordHash = hash;
                delete props.password;
                callback(null, props);
            }
        }
    );
};

// For creating

User.beforeCreate = function(props, callback) {

    if (!props.nickname || !props.password) {
        callback(new Error('Gotta have a nickname and a password.'), null);
        return;
    }

    var now = Stamper.stamp();

    props.published = props.updated = now;

    Step(
        function() {
            bcrypt.genSalt(10, this);
        },
        function(err, salt) {
            if (err) throw err;
            bcrypt.hash(props.password, salt, this);
        },
        function(err, hash) {
            if (err) throw err;
            props.passwordHash = hash;
            delete props.password;
            Person.create({'preferredUsername': props.nickname,
                           url: URLMaker.makeURL(props.nickname),
                           displayName: props.nickname}, this);
        },
        function(err, person) {
            if (err) throw err;
            props.profile = {
                objectType: 'person',
                id: person.id
            };

            Stream.create({name: props.nickname + "-inbox"}, this.parallel());
            Stream.create({name: props.nickname + "-outbox"}, this.parallel());
            Stream.create({name: props.nickname + "-followers"}, this.parallel());
            Stream.create({name: props.nickname + "-following"}, this.parallel());
            Stream.create({name: props.nickname + "-favorites"}, this.parallel());
        },
        function(err, inbox, outbox, followers, following) {
            callback(null, props);
        }
    );
};

User.prototype.sanitize = function() {
    delete this.password;
    delete this.passwordHash;
};

User.prototype.getProfile = function(callback) {
    var user = this;
    Step(
        function() {
            ActivityObject.getObject(user.profile.objectType, user.profile.id, this);
        },
        function(err, profile) {
            if (err) {
                callback(err, null);
            } else {
                callback(null, profile);
            }
        }
    );
};

User.prototype.getStream = function(start, end, callback) {
    var bank = User.bank(),
        user = this,
        ids, activities;

    Step(
        function() {
            Stream.get(user.nickname + '-outbox', this);
        },
        function(err, outbox) {
            if (err) throw err;
            outbox.getIDs(start, end, this);
        },
        function(err, results) {
            if (err) throw err;
            ids = results;
            if (ids.length === 0) {
                callback(null, []);
            } else {
                Activity.readAll(ids, this);
            }
        },
        function(err, map) {
            var i, group = this.group();
            if (err) throw err;
            activities = [];
            // Try to get it in the right order
            for (i = 0; i < ids.length; i++) {
                activities.push(map[ids[i]]);
            }
            // FIXME: batch fetch all actors and objects
            activities.forEach(function(el, i, arr) {
                // remove internal uuid info, if any
                delete el.uuid;
                delete el.actor;
                el.expand(group());
            });
        },
        function(err) {
            if (err) {
                if (err instanceof NoSuchThingError) {
                    callback(null, []);
                } else {
                    callback(err, null);
                }
            } else {
                callback(null, activities);
            }
        }
    );
};

User.prototype.getInbox = function(start, end, callback) {

    var bank = User.bank(),
        user = this,
        activities = null,
        ids;

    Step(
        function() {
            Stream.get(user.nickname + '-inbox', this);
        },
        function(err, inbox) {
            if (err) throw err;
            inbox.getIDs(start, end, this);
        },
        function(err, results) {
            if (err) throw err;
            ids = results;
            if (ids.length === 0) {
                callback(null, []);
            } else {
                Activity.readAll(ids, this);
            }
        },
        function(err, map) {
            var i, group = this.group();
            if (err) throw err;
            activities = [];
            // Try to get it in the right order
            for (i = 0; i < ids.length; i++) {
                activities.push(map[ids[i]]);
            }
            // FIXME: batch fetch all actors and objects
            activities.forEach(function(el, i, arr) {
                // remove internal uuid info, if any
                delete el.uuid;
                el.expand(group());
            });
        },
        function(err) {
            if (err) {
                if (err instanceof NoSuchThingError) {
                    callback(null, []);
                } else {
                    callback(err, null);
                }
            } else {
                callback(null, activities);
            }
        }
    );
};

User.prototype.getFollowers = function(start, end, callback) {
    this.getPeople(this.nickname + '-followers', start, end, callback);
};

User.prototype.getFollowing = function(start, end, callback) {
    this.getPeople(this.nickname + '-following', start, end, callback);
};

User.prototype.getPeople = function(stream, start, end, callback) {
    ActivityObject.getObjectStream('person', stream, start, end, callback);
};

User.prototype.followerCount = function(callback) {
    Stream.count(this.nickname + '-followers', callback);
};

User.prototype.followingCount = function(callback) {
    Stream.count(this.nickname + '-following', callback);
};

User.prototype.follow = function(id, callback) {
    var user = this;
    Step(
        function() {
            Edge.create({from: {id: user.profile.id, objectType: user.profile.objectType},
                         to: {id: id, objectType: "person"}},
                        this);
        },
        function(err, edge) {
            if (err) throw err;
            Stream.get(user.nickname + "-following", this);
        },
        function(err, stream) {
            if (err) throw err;
            stream.deliver(id, this);
        },
        function(err) {
            if (err) throw err;
            User.fromPerson(id, this);
        },
        function(err, other) {
            if (err) throw err;
            if (!other) {
                // XXX: Remote follow
                callback(null);
            } else {
                Stream.get(other.nickname + "-followers", this);
            }
        },
        function(err, stream) {
            if (err) throw err;
            stream.deliver(user.profile.id, this);
        },
        function(err) {
            if (err) {
                callback(err);
            } else {
                callback(null);
            }
        }
    );
};

User.prototype.stopFollowing = function(id, callback) {
    var user = this;
    Step(
        function() {
            Edge.get(Edge.id(user.profile.id, id), this);
        },
        function(err, edge) {
            if (err) throw err;
            edge.del(this);
        },
        function(err) {
            if (err) throw err;
            Stream.get(user.nickname + "-following", this);
        },
        function(err, stream) {
            if (err) throw err;
            stream.remove(id, this);
        },
        function(err) {
            if (err) throw err;
            User.fromPerson(id, this);
        },
        function(err, other) {
            if (err) throw err;
            if (!other) {
                // XXX: Remote follow
                callback(null);
            } else {
                Stream.get(other.nickname + "-followers", this);
            }
        },
        function(err, stream) {
            if (err) throw err;
            stream.remove(user.profile.id, this);
        },
        function(err) {
            if (err) {
                callback(err);
            } else {
                callback(null);
            }
        }
    );
};

User.prototype.favorite = function(id, objectType, callback) {
    var user = this;
    Step(
        function() {
            Favorite.create({from: {id: user.profile.id, objectType: user.profile.objectType},
                             to: {id: id, objectType: objectType}},
                        this);
        },
        function(err, edge) {
            if (err) throw err;
            Stream.get(user.nickname + "-favorites", this);
        },
        function(err, stream) {
            if (err) throw err;
            // XXX: hackery!
            stream.deliver(id+"|"+objectType, this);
        },
        function(err) {
            if (err) throw err;
            ActivityObject.ensureObject({id: id, objectType: objectType}, this);
        },
        function(err, other) {
            if (err) throw err;
            other.favoritedBy(user.profile.id, this);
        },
        function(err) {
            if (err) {
                callback(err);
            } else {
                callback(null);
            }
        }
    );
};

User.prototype.unfavorite = function(id, objectType, callback) {
    var user = this;
    Step(
        function() {
            Favorite.get(Favorite.id(user.profile.id, id), this);
        },
        function(err, favorite) {
            if (err) throw err;
            favorite.del(this);
        },
        function(err) {
            if (err) throw err;
            Stream.get(user.nickname + "-favorites", this);
        },
        function(err, stream) {
            if (err) throw err;
            // XXX: hackery!
            stream.remove(id+"|"+objectType, this);
        },
        function(err) {
            if (err) throw err;
            ActivityObject.ensureObject({id: id, objectType: objectType}, this);
        },
        function(err, other) {
            if (err) throw err;
            other.unfavoritedBy(user.profile.id, this);
        },
        function(err) {
            if (err) {
                callback(err);
            } else {
                callback(null);
            }
        }
    );
};

User.prototype.getFavorites = function(start, end, callback) {
    var user = this,
        ids;

    Step(
        function() {
            Stream.get(user.nickname + "-favorites", this);
        },
        function(err, stream) {
            if (err) throw err;
            stream.getIDs(start, end, this);
        },
        function(err, results) {
            var i, parts, group = this.group();
            if (err) throw err;
            ids = results;
            if (ids.length === 0) {
                callback(null, []);
            } else {
                for (i = 0; i < ids.length; i++) {
                    // XXX: hackery. we pack id|objectType into the id slot. Shh!
                    parts = ids[i].split("|");
                    ActivityObject.getObject(parts[1], parts[0], group());
                }
            }
        },
        function(err, objects) {
            if (err) {
                callback(err, null);
            } else {
                // XXX: I *think* these should be in the same order
                // as ids array.
                callback(null, objects);
            }
        }
    );
};

User.prototype.favoritesCount = function(callback) {
    Stream.count(this.nickname + "-favorites", function(err, count) {
        if (err && err instanceof NoSuchThingError) {
            callback(null, 0);
        } else if (err) {
            callback(err, null);
        } else {
            callback(null, count); 
        }
    });
};

User.prototype.expand = function(callback) {
    var user = this;

    ActivityObject.expandProperty(user, 'profile', callback);
};

User.fromPerson = function(id, callback) {
    Step(
        function() {
            User.search({"profile.id": id}, this);
        },
        function(err, results) {
            if (err) {
                callback(err, null);
            } else if (results.length === 0) {
                callback(null, null);
            } else {
                callback(null, results[0]);
            }
        }
    );
};

User.prototype.addToOutbox = function(activity, callback) {
    var user = this;
    Step(
        function() {
            Stream.get(user.nickname + "-outbox", this);
        },
        function(err, stream) {
            if (err) throw err;
            stream.deliver(activity.id, callback);
        }
    );
};

User.prototype.addToInbox = function(activity, callback) {
    var user = this;
    Step(
        function() {
            Stream.get(user.nickname + "-inbox", this);
        },
        function(err, stream) {
            if (err) throw err;
            stream.deliver(activity.id, callback);
        }
    );
};

// Check the credentials for a user
// callback takes args:
// - err: if there's an error (NB: null if credentials don't match)
// - user: User object or null if credentials don't match

User.checkCredentials = function(nickname, password, callback) {
    var user = null;

    Step(
        function() {
            User.get(nickname, this);
        },
        function(err, result) {
            if (err) {
                if (err instanceof NoSuchThingError) {
                    callback(null, null);
                    return; // done
                } else {
                    throw err;
                }
            } else {
                user = result;
                bcrypt.compare(password, user.passwordHash, this);
            }
        },
        function(err, res) {
            if (err) {
                callback(err, null);
            } else if (!res) {
                callback(null, null);
            } else {
                // Don't percolate that hash around
                user.sanitize();
                callback(null, user);
            }
        }
    );
};

User.schema = {'pkey': 'nickname',
               'fields': ['passwordHash',
                          'published',
                          'updated',
                          'profile'],
               'indices': ['profile.id']};
